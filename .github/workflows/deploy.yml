name: Deploy reportly-api

on:
  push:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      APP_NAME: reportly-api         # 원하는 서비스 이름
      APP_PORT: 8080                 # 스프링 부트 리스닝 포트
      CONTEXT_PATH: ""               # 예) "/reportly-api" 쓰면 내부 헬스도 그 경로로 확인

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 17

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Build with Gradle
        run: ./gradlew clean build -x test

      # 실행가능 JAR 업로드(plain 제외는 원격 선택 단계에서 처리)
      - name: Upload JAR to server
        uses: appleboy/scp-action@v1
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          source: "build/libs/*.jar"
          target: "/home/${{ secrets.SERVER_USER }}/app/"
          overwrite: true

      # 기존 프로세스 정지
      - name: Stop existing app (if any)
        uses: appleboy/ssh-action@v1
        env:
          APP_NAME: ${{ env.APP_NAME }}
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          envs: APP_NAME
          command_timeout: 10m
          script: |
            bash -lc '
              set -Eeuo pipefail
              APP_DIR="/home/${{ secrets.SERVER_USER }}/app"
              JAR_NAME="${APP_NAME}.jar"

              # 자바로 실행된 해당 JAR만 종료
              PIDS="$(pgrep -f "java .*${JAR_NAME}" || true)"
              if [ -z "$PIDS" ]; then
                echo "실행 중인 프로세스 없음."
                exit 0
              fi

              echo "기존 프로세스 종료..."
              kill $PIDS || true
              for i in $(seq 1 15); do pgrep -f "java .*${JAR_NAME}" >/dev/null || break; sleep 1; done
              pgrep -f "java .*${JAR_NAME}" >/dev/null && { echo "SIGKILL..."; kill -9 $PIDS || true; }
              echo "정지 완료"
            '

      # 시작 + 내부 헬스체크
      - name: Start app and internal healthcheck
        uses: appleboy/ssh-action@v1
        env:
          APP_NAME: ${{ env.APP_NAME }}
          APP_PORT: ${{ env.APP_PORT }}
          CONTEXT_PATH: ${{ env.CONTEXT_PATH }}
          DB_CONFIG_JSON: ${{ secrets.DB_CONFIG_JSON }}   # 쓰는 경우만
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          envs: APP_NAME,APP_PORT,CONTEXT_PATH,DB_CONFIG_JSON
          command_timeout: 20m
          script: |
            bash -lc '
              set -Eeuo pipefail

              APP_DIR="/home/${{ secrets.SERVER_USER }}/app"
              JAR_NAME="${APP_NAME}.jar"
              LOG_FILE="$APP_DIR/app.log"

              mkdir -p "$APP_DIR"

              echo "업로드된 JAR 목록:"
              ls -lh "$APP_DIR"/*.jar || true

              # -plain.jar 제외한 최신 JAR 선택
              CANDIDATE="$(ls -t "$APP_DIR"/*.jar 2>/dev/null | grep -v -- "-plain\.jar$" | head -n1 || true)"
              if [ -z "$CANDIDATE" ]; then
                echo "❌ 실행가능 JAR을 찾지 못했습니다. (build/libs/*-plain.jar 제외 여부 확인)"
                exit 1
              fi

              # JAR 이름과 같은 '디렉터리'가 남아 있으면 제거 (여기서 에러의 근본 원인을 해결)
              if [ -d "$APP_DIR/$JAR_NAME" ]; then
                echo "⚠️ $APP_DIR/$JAR_NAME 가 디렉터리입니다. 제거합니다."
                rm -rf "$APP_DIR/$JAR_NAME"
              fi

              # 대상 파일 덮어쓰기
              cp -f "$CANDIDATE" "$APP_DIR/$JAR_NAME"

              # 간단 무결성 점검 (zip 헤더)
              if ! file "$APP_DIR/$JAR_NAME" | grep -qi "zip archive"; then
                echo "❌ 손상된 JAR로 보입니다: $(file "$APP_DIR/$JAR_NAME")"
                exit 1
              fi

              echo "애플리케이션 시작..."
              nohup java -jar "$APP_DIR/$JAR_NAME" --spring.profiles.active=prod > "$LOG_FILE" 2>&1 &

              echo "포트 오픈 대기..."
              for i in $(seq 1 30); do
                ss -ltn 2>/dev/null | awk "{print \$4}" | grep -q ":${APP_PORT}$" && break
                if command -v netstat >/dev/
